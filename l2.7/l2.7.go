package main

import (
	"fmt"
	"math/rand"
	"time"
)

func asChan(vs ...int) <-chan int { // функция принимает неопределенное колво парамертов и делает из них слайс возвращает канал
	c := make(chan int) // создаем канал
	go func() {                // запуск горутины
		for _, v := range vs { // идем по всему срезу
			c <- v                                                        // элементы среза передаем в канал
			time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond) // спим рандное колво миллисекунд от 0 до 999
		}
		close(c) // после работы закрываем канал
	}()
	return c // возвращаем канал
}

func merge(a, b <-chan int) <-chan int { // принимает на вход 2 канала
	c := make(chan int) // создаем канал
	go func() { // запускаем горутину
		for {   // запускаем бесконечный цикл
			select { // в селекте кейсы выбираются смотря на готовность каналов
			case v, ok := <-a:
				if ok { // если канал еще не пуст то добавляем в С
					c <- v
				} else { // в ином случае канал делаем nil
					a = nil
				}
			case v, ok := <-b:
				if ok { // если канал еще не пуст то добавляем в С
					c <- v
				} else { // в ином случае канал делаем nil
					b = nil
				}
			}
			if a == nil && b == nil { // если оба канала станут nil то закрываем канал С и останавливаем цикл
				close(c)
				return
			}
		}
	}()
	return c // возвращаем канал
}

func main() {
	rand.Seed(time.Now().Unix()) // задаем рандомный сид что бы при запусках была разныя генирация
	a := asChan(1, 3, 5, 7)      // задаем 2 переменные которые отправляют числа в функциию
	b := asChan(2, 4, 6, 8)      // задаем 2 переменные которые отправляют числа в функциию
	c := merge(a, b)             // задаем переменную которая вызывает функцию слияния 2 каналов
	for v := range c {           // идем по всем элементам канала
		fmt.Print(v) // выводит рандомном порядке так как мы имеем рандомный слип в функции asChan
	}
}
